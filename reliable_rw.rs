// Copyright 2014 Stacey Ell <stacey.ell@gmail.com>

// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

#![feature(macro_rules)]
extern crate debug;

use std::os;
use std::io;
use std::io::{Command, IoError, EndOfFile};
use std::io::process::{InheritFd, ExitStatus, ExitSignal};

use sha256::{Sha256, Digest};
mod sha256;

static MAGIC_HEADER: &'static [u8] = b"reliable-encap";

// We won't accept any pieces longer than this
static MAX_PIECE_SIZE: uint = 256 * 1024;  // 256kB


// We won't emit any pieces longer than this
static PIECE_SIZE: uint = 32 * 1024;  // 32kB

// Pattern:
//    magic number
//    while (buf = yield_piece()) > 0 {
//        a 32 bit integer, network byte order specifying the piece size `n'
//        the piece: n bytes of data (read from the input stream)
//        the sha256 up until this point.
//    }
//    end magic number generated by adding the magic number to the hash
//

fn strip_dir(fullname: &str) -> String {
    let mut name = String::new();

    for c in fullname.chars().rev() {
        if c == '/' || c == '\\' {
            break;
        }
        name.push_char(c);
    }

    name.as_slice().chars().rev().collect()
}

fn reliable_encap() {
    let args = os::args();
    let program_name = args.get(0).as_slice().clone();
    if args.len() < 2 {
        reliable_encap_print_usage(program_name);
        os::set_exit_status(1);
        return;
    }    

    let mut cmd_args: &[String] = args.tail();
    
    let head = cmd_args.get(0);
    if head.is_some() && head.unwrap().as_slice() == "--" {
        cmd_args = cmd_args.tail();
    } else {
        let mut stderr = io::stderr();
        let warning = "Warning: please include -- before the command name\n";
        assert!(stderr.write(warning.as_bytes()).is_ok());
    }

    let head = cmd_args.get(0);
    if head.is_none() {
        reliable_encap_print_usage(program_name);
        os::set_exit_status(1);
        return;
    }

    let child_executable = head.unwrap(); 
    let mut command = Command::new(child_executable.as_slice());
    for arg in cmd_args.tail().iter() {
        command.arg(arg.as_slice());
    }
    command.stdin(InheritFd(0));  // Better way to do this?
    
    let mut process = match command.spawn() {
        Ok(p) => p,
        Err(e) => fail!("failed to execute process: {}", e),
    };

    let mut output = io::stdout();
    let max_read_len = 32 * 1024;
    
    let mut buf: Vec<u8> = Vec::with_capacity(max_read_len);
    let mut hasher: Box<Digest> = box Sha256::new();
    assert!(output.write(MAGIC_HEADER).is_ok());

    /* appease borrow checker */ {
        let child_output = process.stdout.get_mut_ref();
        loop {
            buf.clear();
            match child_output.push(PIECE_SIZE, &mut buf) {
                // Don't forget to import the different IoError kinds
                // if you are going to catch them.  Otherwise you'll get
                // an E0001 unreachable pattern.
                Ok(n) => {
                    let out_slice = buf.as_slice();
                    assert!(buf.len() == n);
                    assert!(output.write_be_u32(n as u32).is_ok());
                    assert!(output.write(out_slice).is_ok());
                    hasher.input(out_slice);
                    assert!(output.write(hasher.result_bytes().as_slice()).is_ok());
                },
                Err(IoError { kind: EndOfFile, .. }) => {
                    assert!(output.write_be_u32(0).is_ok());
                    assert!(output.write(hasher.result_bytes().as_slice()).is_ok());
                    break;
                },
                Err(err) => fail!("{}", err)
            };
        };
    }
    match process.wait() {
        Ok(ExitStatus(0)) => {
            hasher.input(MAGIC_HEADER);
            match output.write(hasher.result_bytes().as_slice()) {
                Ok(_) => (),
                Err(err) => fail!("{}", err)
            }
            // At this point, even if we fail, the write is complete.
            match output.flush() {
                Ok(_) => (),
                Err(err) => fail!("{}", err)
            }
        },
        Ok(ExitStatus(n)) => {
            os::set_exit_status(n);
        },
        Ok(ExitSignal(_)) => {
            os::set_exit_status(1);
        },
        Err(_) => {
            os::set_exit_status(1);
        }
    }
}

fn reliable_encap_print_usage(program: &str) {
    println!("{} [--] command", program);
}

fn reliable_write() {
    let args = os::args();

    let program_name = args.get(0).as_slice().clone();
    if args.len() < 2 {
        reliable_write_print_usage(program_name);
        os::set_exit_status(1);
        return;
    }

    let mut buf: Vec<u8> = Vec::with_capacity(MAX_PIECE_SIZE);
    let mut input = io::stdin();

    // input.read MAGIC_HEADER.len() and compare to MAGIC_HEADER

    loop {
        match input.read_be_u32() {
            Ok(n) => {
                let n = n as uint;
                if MAX_PIECE_SIZE < n {
                    fail!("excessive piece size");
                }
                if n == 0 {
                    // Terminating
                    break;
                }
                input.push_at_least(n as uint, MAX_PIECE_SIZE, &mut buf);
            },
            Err(err) => fail!("{}", err)
        }
    }
}

fn reliable_write_print_usage(program: &str) {
    println!("{} filename", program);
}

fn print_usage() {
    println!("must be called as either reliable-encap or reliable-write");
}

fn main() {
    let args = os::args();
    let program_name = strip_dir(args.get(0).as_slice());
    match program_name.as_slice() {
        "reliable-encap" => reliable_encap(),
        "reliable-write" => reliable_write(),
        _                => print_usage()
    }
}
