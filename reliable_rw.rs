// Copyright 2014 Stacey Ell <stacey.ell@gmail.com>

// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

#![feature(macro_rules)]
extern crate getopts;
extern crate debug;

use getopts::{optopt,optflag,getopts,OptGroup};
use std::os;
use std::str;

use std::cmp::min;
use std::io;
use std::io::{Command, IoError, EndOfFile, BrokenPipe};
use std::io::process::{InheritFd, ExitStatus, ExitSignal};

use sha256::{Sha256, Digest};
mod sha256;

static MAGIC_HEADER: &'static str = "reliable-encap";

// We won't accept any pieces longer than this
static MAX_PIECE_SIZE: uint = 256 * 1024;  // 256kB

// We won't emit any pieces longer than this
static PIECE_SIZE: uint = 32 * 1024;  // 32kB

// Pattern:
//    magic number
//    while (buf = yield_piece()) > 0 {
//        a 32 bit integer, network byte order specifying the piece size `n'
//        the piece: n bytes of data (read from the input stream)
//        the sha256 up until this point.
//    }
//    end magic number generated by adding the magic number to the hash
//

fn strip_dir(fullname: &str) -> String {
    let mut name = String::new();

    for c in fullname.chars().rev() {
        if c == '/' || c == '\\' {
            break;
        }
        name.push_char(c);
    }

    name.as_slice().chars().rev().collect()
}

fn reliable_encap() {
    let args = os::args();
    if args.len() < 2 {
        reliable_encap_print_usage(args.get(0).as_slice(), []);
    }
    
    let mut command = Command::new(args.get(1).as_slice());
    for i in range(2, args.len()) {
        command.arg(args.get(i).as_slice());
    }
    command.stdin(InheritFd(0));  // Better way to do this?
    

    let mut process = match command.spawn() {
        Ok(p) => p,
        Err(e) => fail!("failed to execute process: {}", e),
    };

    let mut output = io::stdout();
    let max_read_len = 32 * 1024;
    
    let mut buf: Vec<u8> = Vec::with_capacity(max_read_len);
    let mut piece_pos: uint = 0u; 
    let mut hasher: Box<Digest> = box Sha256::new();
    output.write(MAGIC_HEADER.as_bytes());

    /* appease borrow checker */ {
        let mut child_output = process.stdout.get_mut_ref();
        loop {
            let n = match child_output.push(PIECE_SIZE, &mut buf) {
                // Don't forget to import the different IoError kinds
                // if you are going to catch them.  Otherwise you'll get
                // an E0001 unreachable pattern.
                Ok(n) => {
                    /* appease borrow checker */ {
                        let out_slice = buf.as_slice();
                        output.write_be_u32(buf.len() as u32);
                        output.write(out_slice);
                        hasher.input(out_slice);
                        output.write(hasher.result_bytes().as_slice());
                    }
                    buf.clear();
                    piece_pos += n;
                },
                Err(IoError { kind: EndOfFile, .. }) => {
                    output.write_be_u32(0);
                    output.write(hasher.result_bytes().as_slice());
                    break;
                },
                Err(err) => fail!("{}", err)
            };
        };
    }
    match process.wait() {
        Ok(ExitStatus(0)) => {
            hasher.input(MAGIC_HEADER.as_bytes());
            output.write(hasher.result_bytes().as_slice());
            output.flush();
        },
        Ok(ExitStatus(n)) => {
            os::set_exit_status(n);
        },
        Ok(ExitSignal(s)) => {
            os::set_exit_status(1);
        },
        Err(e) => {
            os::set_exit_status(1);
        }
    }
}

fn reliable_encap_print_usage(program: &str, _opts: &[OptGroup]) {
    println!("reliable_encap_print_usage");
}

fn reliable_write() {
    println!("reliable_write");
    let args = os::args();
}

fn reliable_write_print_usage(program: &str, _opts: &[OptGroup]) {
    println!("reliable_write_print_usage");
}

fn print_usage() {
    println!("print_usage");
}

fn main() {
    let args = os::args();
    let program_name = strip_dir(args.get(0).as_slice());
    match program_name.as_slice() {
        "reliable-encap" => reliable_encap(),
        "reliable-write" => reliable_write(),
        _                => print_usage()
    }
}
